<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Gun Game — Multiple Weapons Prototype</title>
<style>
  :root{--bg:#061021;--panel:#0e1722;--accent:#f97316;--muted:#9fb0c9}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#02040a,#051024);color:#e6eef6;padding:12px}
  #gameWrap{width:980px;max-width:96vw;background:linear-gradient(180deg,#081226,#06101a);border-radius:12px;padding:12px;box-shadow:0 8px 40px rgba(2,6,23,0.7)}
  canvas{display:block;background:linear-gradient(180deg,#07202b,#02101a);border-radius:8px;cursor:crosshair}
  .hud{display:flex;justify-content:space-between;align-items:center;margin-top:8px;color:var(--muted);font-size:14px;gap:12px}
  .hud .left strong{color:#dbeafe}
  .btn{background:#0b1220;color:#e6eef6;padding:6px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);cursor:pointer}
  .weapons{display:flex;gap:8px;align-items:center}
  .weaponBtn{padding:8px 10px;border-radius:8px;border:0;background:rgba(255,255,255,0.02);color:#e6eef6;cursor:pointer}
  .weaponBtn.active{outline:2px solid rgba(249,115,22,0.25);transform:translateY(-3px)}
  .small{font-size:12px;color:var(--muted)}
  footer{margin-top:8px;color:var(--muted);font-size:13px;text-align:center}
  .weaponInfo{display:flex;flex-direction:column;gap:2px}
</style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="game" width="920" height="560"></canvas>

    <div class="hud" style="flex-wrap:wrap">
      <div style="display:flex;gap:14px;align-items:center">
        <div>
          <strong>HP:</strong> <span id="hp">100</span>
          &nbsp;&nbsp;<strong>Score:</strong> <span id="score">0</span>
        </div>
        <div id="ammoUI" class="small">Ammo: —</div>
      </div>

      <div class="weapons" id="weaponsBar">
        <!-- buttons added by JS -->
      </div>

      <div style="display:flex;align-items:center;gap:8px">
        <button class="btn" id="restart">Restart</button>
        <div class="small">WASD move • Mouse aim • Click to shoot • R reload • 1-4 switch</div>
      </div>
    </div>

    <footer>Weapons are game mechanics only. Modify constants in script to tune.</footer>
  </div>

<script>
/* ===== Multi-Weapon Top-Down Shooter =====
   Weapons:
     1: Glock (fast pistol, semi-auto)
     2: Smith (weaker pistol, auto)
     3: Hunting Rifle (bolt-action, high damage, slow)
     4: SPAS Shotgun (pellets, spread)
   Controls:
     WASD - move
     Mouse - aim
     Left click - shoot (hold for auto)
     R - reload
     1-4 - switch weapons
*/

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const WIDTH = canvas.width, HEIGHT = canvas.height;

const hud = {
  hp: document.getElementById('hp'),
  score: document.getElementById('score'),
  ammoUI: document.getElementById('ammoUI'),
  weaponsBar: document.getElementById('weaponsBar')
};

const PLAYER_RADIUS = 14;
const PLAYER_SPEED = 220;
const PLAYER_MAX_HP = 100;
let keys = {}, mouse = {x: WIDTH/2, y: HEIGHT/2, down: false};
let lastFrame = performance.now();
let bullets = [], enemies = [];
let lastSpawn = 0;
let running = true;

/* ===== Weapon definitions =====
   name, fireRate(ms), magSize, reload(ms), bulletSpeed(px/s), damage, pellets, spread(deg), automatic(bool), reserve (initial)
*/
const WEAPONS = [
  {
    id: 'glock',
    name: 'Glock',
    fireRate: 180,
    magSize: 15,
    reloadTime: 650,
    bulletSpeed: 780,
    damage: 22,
    pellets: 1,
    spread: 0,
    automatic: false,
    reserveAmmo: 90,
    color: '#fef08a'
  },
  {
    id: 'smith',
    name: 'Smith',
    fireRate: 120,
    magSize: 12,
    reloadTime: 800,
    bulletSpeed: 720,
    damage: 18,
    pellets: 1,
    spread: 0,
    automatic: true,
    reserveAmmo: 120,
    color: '#60a5fa'
  },
  {
    id: 'rifle',
    name: 'Hunting Rifle',
    fireRate: 900,
    magSize: 5,
    reloadTime: 1100,
    bulletSpeed: 1200,
    damage: 95,
    pellets: 1,
    spread: 0,
    automatic: false,
    reserveAmmo: 25,
    color: '#f97316'
  },
  {
    id: 'spas',
    name: 'SPAS Shotgun',
    fireRate: 800,
    magSize: 8,
    reloadTime: 900,
    bulletSpeed: 640,
    damage: 10,      // per pellet
    pellets: 8,      // pellets per shot
    spread: 18,      // degrees cone
    automatic: false,
    reserveAmmo: 40,
    color: '#f87171'
  }
];

// Per-player weapon state (mag + reserve + reloading)
let weaponsState = WEAPONS.map(w => ({
  id: w.id,
  current: w.magSize,
  reserve: w.reserveAmmo,
  reloading: false,
}));

let currentWeaponIndex = 0;
let lastShotAt = 0;

let player = {
  x: WIDTH/2, y: HEIGHT/2,
  vx:0, vy:0, hp: PLAYER_MAX_HP,
  score: 0
};

/* Utility */
function rand(min,max){ return Math.random()*(max-min)+min; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function degToRad(d){ return d * Math.PI/180; }

/* Input */
window.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  if(e.key === 'r' || e.key === 'R') reload();
  if(['1','2','3','4'].includes(e.key)) {
    const idx = Number(e.key) - 1;
    if(idx >= 0 && idx < WEAPONS.length) switchWeapon(idx);
  }
});
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
canvas.addEventListener('mousemove', e => {
  const r = canvas.getBoundingClientRect();
  mouse.x = (e.clientX - r.left) * (canvas.width / r.width);
  mouse.y = (e.clientY - r.top) * (canvas.height / r.height);
});
canvas.addEventListener('mousedown', e => mouse.down = true);
canvas.addEventListener('mouseup', e => mouse.down = false);
document.getElementById('restart').addEventListener('click', resetGame);

/* Weapon UI buttons */
function buildWeaponButtons(){
  hud.weaponsBar.innerHTML = '';
  WEAPONS.forEach((w, i) => {
    const btn = document.createElement('button');
    btn.className = 'weaponBtn' + (i===currentWeaponIndex ? ' active':'');
    btn.innerHTML = `<div class="weaponInfo"><strong style="font-size:13px">${i+1}. ${w.name}</strong><span style="font-size:12px" id="w-${w.id}">mag ${weaponsState[i].current}/${w.magSize} • ${weaponsState[i].reserve}</span></div>`;
    btn.addEventListener('click', ()=> switchWeapon(i));
    hud.weaponsBar.appendChild(btn);
  });
}
buildWeaponButtons();

/* Switch weapon */
function switchWeapon(idx){
  if(idx === currentWeaponIndex) return;
  currentWeaponIndex = idx;
  // visual update
  const children = hud.weaponsBar.children;
  for(let i=0;i<children.length;i++){
    children[i].classList.toggle('active', i===currentWeaponIndex);
  }
  updateAmmoUI();
}

/* Shoot logic */
function canShoot(){
  const w = WEAPONS[currentWeaponIndex];
  const ws = weaponsState[currentWeaponIndex];
  if(ws.reloading) return false;
  const now = performance.now();
  if(now - lastShotAt < w.fireRate) return false;
  if(ws.current <= 0) return false;
  return true;
}

function shoot(){
  if(!canShoot()) return;
  const w = WEAPONS[currentWeaponIndex];
  const ws = weaponsState[currentWeaponIndex];
  // semi-auto: only allow shot on mousedown edge for non-automatic weapons
  if(!w.automatic){
    if(!mouse.down) return; // require click (must press)
    // To prevent firing repeatedly without releasing, ensure lastShotAt check suffices.
  }

  lastShotAt = performance.now();

  // For shotgun: spawn multiple pellets with spread
  for(let p=0;p<w.pellets;p++){
    const baseAngle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
    let angle = baseAngle;
    if(w.pellets > 1 && w.spread > 0){
      // distribute pellets across cone with randomness
      const half = w.spread/2;
      const offsetDeg = rand(-half, half);
      angle += degToRad(offsetDeg);
    }
    const vx = Math.cos(angle) * w.bulletSpeed;
    const vy = Math.sin(angle) * w.bulletSpeed;
    bullets.push({
      x: player.x + Math.cos(angle)*(PLAYER_RADIUS+8),
      y: player.y + Math.sin(angle)*(PLAYER_RADIUS+8),
      vx, vy,
      life: 1.6,
      dmg: w.damage,
      color: w.color || '#ffd166',
      ownerWeapon: w.id
    });
  }

  ws.current = Math.max(0, ws.current - 1);
  updateAmmoUI();
  // Auto reload when empty and reserve > 0 (optional)
  if(ws.current === 0 && ws.reserve > 0){
    // small delay before auto reload to feel natural
    setTimeout(()=> reload(), 280);
  }
}

/* Reload */
function reload(){
  const idx = currentWeaponIndex;
  const w = WEAPONS[idx];
  const ws = weaponsState[idx];
  if(ws.reloading) return;
  if(ws.current === w.magSize) return;
  if(ws.reserve <= 0) return;
  ws.reloading = true;
  const start = performance.now();
  // simple reload timer
  setTimeout(()=>{
    const needed = w.magSize - ws.current;
    const taken = Math.min(needed, ws.reserve);
    ws.current += taken;
    ws.reserve -= taken;
    ws.reloading = false;
    updateAmmoUI();
  }, w.reloadTime);
  updateAmmoUI();
}

/* Spawn enemies - simple chasers */
function spawnEnemy(){
  let x,y;
  const side = Math.floor(rand(0,4));
  if(side===0){ x = rand(-40, WIDTH+40); y = -30; }
  if(side===1){ x = rand(-40, WIDTH+40); y = HEIGHT+30; }
  if(side===2){ x = -40; y = rand(-20, HEIGHT+20); }
  if(side===3){ x = WIDTH+40; y = rand(-20, HEIGHT+20); }
  enemies.push({
    x, y,
    size: rand(12, 20),
    hp: rand(40, 70),
    speed: rand(50, 95),
    color: '#ff6b6b'
  });
}

/* Collision helpers */
function bulletHitsEnemy(b, e){
  const dx = b.x - e.x, dy = b.y - e.y;
  return dx*dx + dy*dy <= e.size*e.size;
}

/* Update ammo UI (and per-weapon labels) */
function updateAmmoUI(){
  const w = WEAPONS[currentWeaponIndex];
  const ws = weaponsState[currentWeaponIndex];
  hud.ammoUI.textContent = `${w.name}: ${ws.current}/${w.magSize} (${ws.reserve} reserve)` + (ws.reloading ? ' • Reloading...' : '');
  // update buttons labels
  WEAPONS.forEach((weapon, i)=>{
    const el = document.getElementById('w-' + weapon.id);
    if(el){
      el.textContent = `mag ${weaponsState[i].current}/${weapon.magSize} • ${weaponsState[i].reserve}`;
    }
  });
}

/* Game update & draw */
function update(dt){
  if(!running) return;

  // Movement
  let dx=0, dy=0;
  if(keys['w']) dy -= 1;
  if(keys['s']) dy += 1;
  if(keys['a']) dx -= 1;
  if(keys['d']) dx += 1;
  const len = Math.hypot(dx,dy) || 1;
  player.vx = (dx/len) * PLAYER_SPEED;
  player.vy = (dy/len) * PLAYER_SPEED;
  player.x += player.vx * dt;
  player.y += player.vy * dt;
  player.x = clamp(player.x, PLAYER_RADIUS, WIDTH-PLAYER_RADIUS);
  player.y = clamp(player.y, PLAYER_RADIUS, HEIGHT-PLAYER_RADIUS);

  // Shooting: automatic weapons fire while mouse down
  const w = WEAPONS[currentWeaponIndex];
  if(w.automatic){
    if(mouse.down) shoot();
  } else {
    // for semi-auto, allow shot on mouse press (we already rely on timing)
    if(mouse.down) {
      // to ensure single-shot per click for semi, we can require lastShotAt delay which exists
      // nothing extra here — user can click repeatedly
      shoot();
    }
  }

  // Bullets movement & lifetime & collisions
  for(let i = bullets.length-1; i >= 0; i--){
    const b = bullets[i];
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    b.life -= dt;
    if(b.life <= 0 || b.x < -50 || b.x > WIDTH+50 || b.y < -50 || b.y > HEIGHT+50){
      bullets.splice(i,1);
      continue;
    }
    // check collisions
    for(let j = enemies.length-1; j >= 0; j--){
      const e = enemies[j];
      if(bulletHitsEnemy(b,e)){
        e.hp -= b.dmg;
        // small knockback
        e.x += (b.vx * 0.015);
        e.y += (b.vy * 0.015);
        bullets.splice(i,1);
        if(e.hp <= 0){
          player.score += Math.floor(10 + e.size*2);
          enemies.splice(j,1);
        }
        break;
      }
    }
  }

  // Enemies chase player & touch damage
  enemies.forEach(e => {
    const ang = Math.atan2(player.y - e.y, player.x - e.x);
    e.x += Math.cos(ang) * e.speed * dt;
    e.y += Math.sin(ang) * e.speed * dt;
    const d = Math.hypot(e.x - player.x, e.y - player.y);
    if(d < e.size + PLAYER_RADIUS){
      // damage player over time
      player.hp -= 18 * dt; // 18 hp per second while touching
      // push enemy back a little
      e.x -= Math.cos(ang) * 6;
      e.y -= Math.sin(ang) * 6;
    }
  });

  // Spawn new enemies periodically
  if(performance.now() - lastSpawn > 1100){
    spawnEnemy();
    lastSpawn = performance.now();
  }

  // Update HUD
  hud.hp.textContent = Math.max(0, Math.round(player.hp));
  hud.score.textContent = player.score;
  updateAmmoUI();

  if(player.hp <= 0){
    running = false;
  }
}

function draw(){
  ctx.clearRect(0,0,WIDTH,HEIGHT);

  // background subtle grid
  ctx.save();
  ctx.globalAlpha = 0.06;
  ctx.strokeStyle = '#ffffff';
  for(let x=0;x<WIDTH;x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,HEIGHT); ctx.stroke(); }
  for(let y=0;y<HEIGHT;y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(WIDTH,y); ctx.stroke(); }
  ctx.restore();

  // bullets
  bullets.forEach(b => {
    ctx.beginPath();
    ctx.fillStyle = b.color || '#ffd166';
    ctx.arc(b.x, b.y, 3, 0, Math.PI*2);
    ctx.fill();
  });

  // enemies
  enemies.forEach(e => {
    ctx.beginPath();
    ctx.fillStyle = e.color;
    ctx.arc(e.x, e.y, e.size, 0, Math.PI*2);
    ctx.fill();
    // hp bar
    ctx.fillStyle = '#111827';
    ctx.fillRect(e.x - e.size, e.y - e.size - 8, e.size*2, 5);
    ctx.fillStyle = '#60a5fa';
    const ratio = clamp(e.hp / 60, 0, 1);
    ctx.fillRect(e.x - e.size, e.y - e.size - 8, (e.size*2) * ratio, 5);
  });

  // player (rotated toward mouse)
  const ang = Math.atan2(mouse.y - player.y, mouse.x - player.x);
  ctx.save();
  ctx.translate(player.x, player.y);
  ctx.rotate(ang);
  // body
  ctx.beginPath();
  ctx.fillStyle = '#60a5fa';
  ctx.arc(0,0,PLAYER_RADIUS,0,Math.PI*2);
  ctx.fill();
  // muzzle/gun
  ctx.fillStyle = '#111827';
  ctx.fillRect(8, -6, PLAYER_RADIUS+12, 12);
  ctx.restore();

  // crosshair
  ctx.beginPath();
  ctx.strokeStyle = '#fef3c7';
  ctx.setLineDash([4,6]);
  ctx.moveTo(mouse.x-12, mouse.y); ctx.lineTo(mouse.x+12, mouse.y);
  ctx.moveTo(mouse.x, mouse.y-12); ctx.lineTo(mouse.x, mouse.y+12);
  ctx.stroke();
  ctx.setLineDash([]);

  // overlay when reloading
  const ws = weaponsState[currentWeaponIndex];
  if(ws.reloading){
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(0, HEIGHT-36, WIDTH, 36);
    ctx.fillStyle = '#fef3c7';
    ctx.font = '16px Inter, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Reloading...', WIDTH/2, HEIGHT-12);
    ctx.restore();
  }

  // game over
  if(!running){
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0,0,WIDTH,HEIGHT);
    ctx.fillStyle = '#ffb4b4';
    ctx.font = '48px Inter, system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('You were defeated', WIDTH/2, HEIGHT/2 - 10);
    ctx.fillStyle = '#fef3c7';
    ctx.font = '20px Inter, system-ui, sans-serif';
    ctx.fillText('Press Restart to try again', WIDTH/2, HEIGHT/2 + 30);
    ctx.restore();
  }
}

/* Main loop */
function loop(now){
  const dt = Math.min(0.05, (now - lastFrame) / 1000);
  lastFrame = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

/* Reset game */
function resetGame(){
  bullets = [];
  enemies = [];
  player.x = WIDTH/2; player.y = HEIGHT/2;
  player.hp = PLAYER_MAX_HP;
  player.score = 0;
  running = true;
  lastSpawn = performance.now();
  // reset weapons state (keep reserves? we reset them)
  weaponsState = WEAPONS.map(w => ({ id: w.id, current: w.magSize, reserve: w.reserveAmmo, reloading: false }));
  buildWeaponButtons();
  updateAmmoUI();
}

/* initial */
resetGame();
requestAnimationFrame(loop);

/* Helpers for debug: spawn more enemies with 1/2 keys */
window.addEventListener('keydown', (e)=>{
  if(e.key === '1' && !e.ctrlKey) spawnEnemy();
});

/* Prevent continuous semi-auto firing without clicking repeatedly:
   We already use lastShotAt timing + whether weapon is automatic. For semi-auto,
   users should click to fire; holding down will spam bullets but lastShotAt prevents overly fast fire.
*/
</script>
</body>
</html>

